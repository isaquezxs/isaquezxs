
-- Carrega a biblioteca UI Redz APÓS a tela de loading
local success, redzlib = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
if not success then
    warn("Erro ao carregar a biblioteca UI")
    return
end

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://18751483361", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(35, 1) },
})

-- Tab1: Credits
local Tab1 = Window:MakeTab({"Credits", "info"})

Tab1:AddDiscordInvite({
    Name = "Shadow Hub",
    Description = "Join server",
    Logo = "rbxassetid://18751483361",
    Invite = "https://discord.gg/tsxKumHC",
})

Window:SelectTab(Tab1)

local Section = Tab1:AddSection({"Créditos"})

Tab1:AddParagraph({"Criador", "isaquexsz"})
Tab1:AddParagraph({"Versão", "BETA"})
Tab1:AddParagraph({"Executor", "KRNL/Synapse"})
Tab1:AddParagraph({"Jogadores Online", tostring(#game.Players:GetPlayers())})

-- Tab2: Funções Principais
local Tab2 = Window:MakeTab({"Admin", "Home"})

Tab2:AddSection({"Painel Admin Shadow"})

-- PAINEL ADM CORRIGIDO - AGORA NA TAB2
Tab2:AddButton({"Painel Adm", function()
    local Version = "1.6.41"
    local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/download/" .. Version .. "/main.lua"))()
    local Window = WindUI:CreateWindow({
        Title = "Admin Shadow",
        Icon = "shield",
        Author = "By isaquexsz",
        Folder = "Shadow",
        Size = UDim2.fromOffset(330, 220),
        Transparent = true,
        Theme = "Red",
        Resizable = true,
        SideBarWidth = 200,
        Background = "8652665149",
        BackgroundImageTransparency = 0.10,
        HideSearchBar = true,
        ScrollBarEnabled = false,
        User = {
            Enabled = true,
            Xxxhey_lorenzo1 = true,
            Callback = function()
                print("clicked")
            end,
        },
        KeySystem = {
            Key = { "isaquexsz9992", "PainelAdm" },
            Note = "Painel Shadow Scripts by Doggeblox studios",
            Thumbnail = {
                Image = "rbxassetid://8652665149",
                Title = "Key system",
            },
            URL = "https://github.com/Footagesus/WindUI",
            SaveKey = true,
        },
    })

    Window:EditOpenButton({
        Title = "Painel Shadow hub by doggeblox studios",
        Icon = "shield",
        CornerRadius = UDim.new(0,16),
        StrokeThickness = 2,
        Color = ColorSequence.new(
            Color3.fromHex("FF0000"), 
            Color3.fromHex("FFFFFF")
        ),
        OnlyMobile = false,
        Enabled = true,
        Draggable = true,
    })

    local Tab = Window:Tab({
        Title = "Protetion",
        Icon = "skull",
        Locked = false,
    })

    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local StarterGui = game:GetService("StarterGui")
    local HttpService = game:GetService("HttpService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local TextChatService = game:GetService("TextChatService")

    -- Gera lista com todos os nomes dos jogadores
    local playerNames = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        table.insert(playerNames, plr.Name)
    end

    -- Variável para armazenar os jogadores selecionados no Dropdown
    local selectedPlayers = {}

    local Dropdown = Tab:Dropdown({
        Title = "Selecionar Jogadores",
        Values = playerNames,
        Value = {},
        Multi = true,
        AllowNone = true,
        Callback = function(newSelectedPlayers)
            selectedPlayers = newSelectedPlayers
            print("Jogadores selecionados: " .. HttpService:JSONEncode(selectedPlayers))
        end
    })

    -- Atualiza lista automaticamente quando entra ou sai jogador
    Players.PlayerAdded:Connect(function(plr)
        table.insert(playerNames, plr.Name)
        Dropdown:SetValues(playerNames)
    end)

    Players.PlayerRemoving:Connect(function(plr)
        for i, name in ipairs(playerNames) do
            if name == plr.Name then
                table.remove(playerNames, i)
                break
            end
        end
        Dropdown:SetValues(playerNames)
    end)

    -- Adiciona o Toggle para View Player na aba Protetion
    local ViewToggle = Tab:Toggle({
        Title = "Visualizar Jogador",
        Icon = "eye",
        Default = false,
        Callback = function(state)
            if state then
                if #selectedPlayers > 0 then
                    local targetPlayerName = selectedPlayers[1]
                    local targetPlayer = Players:FindFirstChild(targetPlayerName)
                    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local camera = workspace.CurrentCamera
                        camera.CameraSubject = targetPlayer.Character.Humanoid
                        camera.CameraType = Enum.CameraType.Follow
                        StarterGui:SetCore("SendNotification", {
                            Title = "Visualizando",
                            Text = "Câmera focada em " .. targetPlayer.Name,
                            Duration = 3
                        })
                    else
                        ViewToggle:Set(false)
                        StarterGui:SetCore("SendNotification", {
                            Title = "Erro",
                            Text = "Jogador " .. targetPlayerName .. " não encontrado ou sem personagem!",
                            Duration = 3
                        })
                    end
                else
                    ViewToggle:Set(false)
                    StarterGui:SetCore("SendNotification", {
                        Title = "Erro",
                        Text = "Nenhum jogador selecionado no Dropdown!",
                        Duration = 3
                    })
                end
            else
                local camera = workspace.CurrentCamera
                camera.CameraSubject = LocalPlayer.Character and LocalPlayer.Character.Humanoid
                camera.CameraType = Enum.CameraType.Custom
                StarterGui:SetCore("SendNotification", {
                    Title = "Visualização Desativada",
                    Text = "Câmera restaurada para o seu personagem.",
                    Duration = 3
                })
            end
        end
    })

    -- Função para enviar mensagens no chat
    local function sendChatMessage(message)
        local success = pcall(function()
            if TextChatService and TextChatService.TextChannels then
                local channel = TextChatService.TextChannels.RBXGeneral
                if channel then
                    channel:SendAsync(message)
                end
            else
                game.Players:Chat(message)
            end
        end)
        return success
    end

    -- Adiciona o Botão Verifique na aba Protetion
    local VerifyButton = Tab:Button({
        Title = "Verifique",
        Icon = "check",
        Callback = function()
            local success1 = sendChatMessage("/Verifique")
            wait(0.5)
            local success2 = sendChatMessage("Shadow_###")
            
            if success1 and success2 then
                StarterGui:SetCore("SendNotification", {
                    Title = "Verificação",
                    Text = "Comandos '/Verifique e 'Shadow hub' enviados no chat!",
                    Duration = 3
                })
            else
                StarterGui:SetCore("SendNotification", {
                    Title = "Erro",
                    Text = "Falha ao enviar uma ou ambas as mensagens no chat!",
                    Duration = 3
                })
            end
        end
    })

    print("Painel adm adicionado!")
end})

-- Tab3: Troll
local Tab3 = Window:MakeTab({"Troll", "skull"})

Tab3:AddSection({"Troll"})

-- Variáveis globais otimizadas
local selectedPlayerName = nil
local methodKill = ""
local flingActive = false
local boatFlingActive = false

-- Função para obter lista de jogadores (otimizada)
local function getPlayerList()
    local players = Players:GetPlayers()
    local playerNames = {}
    for _, player in ipairs(players) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Dropdown para selecionar jogador
local killDropdown = Tab3:AddDropdown({
    Name = "Selecionar Jogador",
    Description = "Escolha um jogador para trollar",
    Options = getPlayerList(),
    Default = "",
    Callback = function(value)
        selectedPlayerName = value
        getgenv().Target = value
        game.StarterGui:SetCore("SendNotification", {
            Title = "Jogador Selecionado",
            Text = value .. " selecionado!",
            Duration = 3
        })
    end
})

-- Botão para atualizar lista de jogadores
Tab3:AddButton({
    Name = "Atualizar Player List",
    Callback = function()
        local newPlayers = getPlayerList()
        if killDropdown then
            killDropdown:Set(newPlayers)
        end
        game.StarterGui:SetCore("SendNotification", {
            Title = "Lista Atualizada",
            Text = "Lista de jogadores atualizada!",
            Duration = 3
        })
    end
})

-- Função Spectar Jogador (otimizada)
Tab3:AddToggle({
    Name = "Spectar Player",
    Default = false,
    Callback = function(value)
        local Camera = workspace.CurrentCamera

        if value then
            if getgenv().CameraConnection then
                getgenv().CameraConnection:Disconnect()
            end
            
            getgenv().CameraConnection = RunService.Heartbeat:Connect(function()
                if value and selectedPlayerName then
                    local targetPlayer = Players:FindFirstChild(selectedPlayerName)
                    if targetPlayer and targetPlayer.Character then
                        local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
                        if humanoid then
                            Camera.CameraSubject = humanoid
                            return
                        end
                    end
                end
                if LocalPlayer.Character then
                    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                    if humanoid then
                        Camera.CameraSubject = humanoid
                    end
                end
            end)
        else
            if getgenv().CameraConnection then
                getgenv().CameraConnection:Disconnect()
                getgenv().CameraConnection = nil
            end
            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    Camera.CameraSubject = humanoid
                end
            end
        end
    end
})

-- Botão para teleportar até o jogador
Tab3:AddButton({
    Name = "Teleportar até o Player",
    Callback = function()
        if not selectedPlayerName then return end
        
        local character = LocalPlayer.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end

        local targetPlayer = Players:FindFirstChild(selectedPlayerName)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            humanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
            game.StarterGui:SetCore("SendNotification", {
                Title = "TP Concluído",
                Text = "Teleportado até " .. selectedPlayerName,
                Duration = 5
            })
        end
    end
})

Tab3:AddSection({""})

-- Seção Fling
Tab3:AddSection({Name = "Fling e kill"})

-- Auto Fling otimizado
Tab3:AddToggle({
    Name = "Auto Fling",
    Default = false,
    Callback = function(state)
        flingActive = state
        if state then
            if not selectedPlayerName then
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Erro",
                    Text = "Selecione um jogador primeiro!",
                    Duration = 3
                })
                flingActive = false
                return
            end
            
            local target = Players:FindFirstChild(selectedPlayerName)
            if not target or not target.Character then return end
            
            local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local tRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
            if not root or not tRoot then return end
            
            local char = LocalPlayer.Character
            local hum = char:FindFirstChildOfClass("Humanoid")
            local original = root.CFrame

            -- Limpar ferramentas
            ReplicatedStorage.RE["1Clea1rTool1s"]:FireServer("ClearAllTools")
            task.wait(0.2)

            -- Spawnar sofá
            ReplicatedStorage.RE:FindFirstChild("1Too1l"):InvokeServer("PickingTools", "Couch")
            task.wait(0.3)
            
            local tool = LocalPlayer.Backpack:FindFirstChild("Couch")
            if tool then
                tool.Parent = char
            end
            
            task.wait(0.2)
            -- Simular tecla F
            game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.F, false, game)
            task.wait(0.25)

            -- Configurar fling
            local bv = Instance.new("BodyVelocity")
            bv.Name = "FlingForce"
            bv.Velocity = Vector3.new(9e8, 9e8, 9e8)
            bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bv.Parent = root
            
            hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
            hum.PlatformStand = false

            -- Loop de fling
            task.spawn(function()
                while flingActive and target and target.Character do
                    local tHum = target.Character:FindFirstChildOfClass("Humanoid")
                    if tHum and tHum.Sit then break end
                    
                    local targetPos = tRoot.Position + (tRoot.Velocity / 1.5)
                    root.CFrame = CFrame.new(targetPos) * CFrame.Angles(math.rad(tick() * 100), 0, 0)
                    
                    root.Velocity = Vector3.new(9e8, 9e8, 9e8)
                    task.wait()
                end
                
                -- Cleanup
                if bv then bv:Destroy() end
                hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                hum.PlatformStand = false
                if root then root.CFrame = original end
                
                -- Limpar ferramentas
                ReplicatedStorage.RE["1Clea1rTool1s"]:FireServer("ClearAllTools")
            end)
        end
    end
})

-- Variável global para controlar o Fling - Boat
local boatFlingConnection = nil

-- Botão Fling - Boat CORRIGIDO
Tab3:AddButton({
    Name = "Fling - Boat",
    Callback = function()
        if not selectedPlayerName or not game.Players:FindFirstChild(selectedPlayerName) then
            warn("Nenhum jogador selecionado ou não existe")
            return
        end

        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")

        if not Humanoid or not RootPart then
            warn("Humanoid ou RootPart inválido")
            return
        end

        -- Deletar barco existente
        local existingBoat = Vehicles:FindFirstChild(Player.Name.."Car")
        if existingBoat then
            existingBoat:Destroy()
        end

        -- Spawnar novo barco
        RootPart.CFrame = CFrame.new(1754, -2, 58)
        task.wait(0.5)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingBoat", "MilitaryBoatFree")
        task.wait(2)
        
        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if not PCar then
            warn("Falha ao spawnar o barco")
            return
        end

        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if not Seat then
            warn("Assento não encontrado")
            return
        end

        -- Entrar no barco
        RootPart.CFrame = Seat.CFrame * CFrame.new(0, 2, 0)
        task.wait(0.5)

        if not Humanoid.Sit then
            repeat 
                task.wait(0.1)
                RootPart.CFrame = Seat.CFrame * CFrame.new(0, 1, 0)
            until Humanoid.Sit or not PCar.Parent
        end

        if not Humanoid.Sit then
            warn("Não foi possível entrar no barco")
            return
        end

        print("Barco spawnado e jogador entrou!")

        local TargetPlayer = game.Players:FindFirstChild(selectedPlayerName)
        if not TargetPlayer or not TargetPlayer.Character then
            warn("Jogador não encontrado")
            return
        end

        local TargetC = TargetPlayer.Character
        local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
        local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")

        if not TargetRP or not TargetH then
            warn("Humanoid ou RootPart do alvo não encontrado")
            return
        end

        -- Adicionar força angular para girar
        local Spin = Instance.new("BodyAngularVelocity")
        Spin.Name = "Spinning"
        Spin.Parent = PCar.PrimaryPart
        Spin.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        Spin.AngularVelocity = Vector3.new(0, 50, 0)

        -- Adicionar velocidade linear
        local BodyVelocity = Instance.new("BodyVelocity")
        BodyVelocity.Name = "FlingVelocity"
        BodyVelocity.Parent = PCar.PrimaryPart
        BodyVelocity.Velocity = Vector3.new(0, 50, 0)
        BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

        print("Fling ativo!")

        boatFlingActive = true

        -- Conexão para o fling
        boatFlingConnection = RunService.Heartbeat:Connect(function()
            if not boatFlingActive or not PCar or not PCar.Parent or not TargetRP or not TargetRP.Parent then
                if boatFlingConnection then
                    boatFlingConnection:Disconnect()
                    boatFlingConnection = nil
                end
                return
            end

            -- Atualizar posição do barco para seguir o alvo
            local targetPos = TargetRP.Position + Vector3.new(0, 3, 0)
            local offset = Vector3.new(
                math.sin(tick() * 5) * 3,
                math.cos(tick() * 3) * 2,
                math.cos(tick() * 5) * 3
            )
            
            PCar:SetPrimaryPartCFrame(CFrame.new(targetPos + offset) * CFrame.Angles(math.rad(tick() * 100), math.rad(tick() * 80), math.rad(tick() * 60)))
            
            -- Atualizar velocidades
            Spin.AngularVelocity = Vector3.new(math.sin(tick()) * 100, math.cos(tick()) * 100, math.sin(tick()) * 100)
            BodyVelocity.Velocity = (TargetRP.Position - PCar.PrimaryPart.Position).Unit * 50 + Vector3.new(0, 30, 0)
        end)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Fling - Boat",
            Text = "Ativo! Use 'Desligar Fling' para parar",
            Duration = 5
        })
    end
})

-- Botão Desligar Fling - Boat CORRIGIDO
Tab3:AddButton({
    Name = "Desligar Fling - Boat",
    Callback = function()
        boatFlingActive = false
        
        if boatFlingConnection then
            boatFlingConnection:Disconnect()
            boatFlingConnection = nil
        end

        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        
        -- Deletar barco
        local PCar = Vehicles and Vehicles:FindFirstChild(Player.Name.."Car")
        if PCar then
            -- Remover forças físicas
            for _, obj in pairs(PCar:GetDescendants()) do
                if obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity") then
                    obj:Destroy()
                end
            end
            PCar:Destroy()
        end

        -- Sair do veículo se estiver sentado
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            Humanoid.Sit = false
            Humanoid.PlatformStand = false
        end

        -- Remover forças do personagem
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        if RootPart then
            for _, obj in pairs(RootPart:GetChildren()) do
                if obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity") or obj:IsA("BodyPosition") or obj:IsA("BodyGyro") then
                    obj:Destroy()
                end
            end
        end

        game.StarterGui:SetCore("SendNotification", {
            Title = "Fling - Boat",
            Text = "Desativado com sucesso!",
            Duration = 5
        })
    end
})

-- Tab4: Scripts Trolls 
local Tab4 = Window:MakeTab({"Scripts Trolls", "fire"})

Tab4:AddSection({"Invisibilidade"})

Tab4:AddButton({"Ficar Invisível", function()
    local character = LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 1
            end
        end
    end
end})

Tab4:AddButton({"Voltar ao Normal", function()
    local character = LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 0
            end
        end
    end
end})

-- BLACK HOLE ADICIONADO AQUI
Tab4:AddSection({"Black Hole"})

Tab4:AddButton({
    Name = "Black Hole",
    Description = "Ativando isso você puxa Parts até o seu personagem",
    Callback = function()
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local LocalPlayer = Players.LocalPlayer
        local Workspace = game:GetService("Workspace")

        local angle = 1
        local radius = 10
        local blackHoleActive = false
        local angleSpeed = 2

        local function setupPlayer()
            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

            local Folder = Instance.new("Folder", Workspace)
            Folder.Name = "BlackHoleFolder"
            local Part = Instance.new("Part", Folder)
            local Attachment1 = Instance.new("Attachment", Part)
            Part.Anchored = true
            Part.CanCollide = false
            Part.Transparency = 1

            return humanoidRootPart, Attachment1
        end

        local humanoidRootPart, Attachment1 = setupPlayer()

        if not getgenv().Network then
            getgenv().Network = {
                BaseParts = {},
                Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
            }

            Network.RetainPart = function(part)
                if typeof(part) == "Instance" and part:IsA("BasePart") and part:IsDescendantOf(Workspace) then
                    table.insert(Network.BaseParts, part)
                    part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                    part.CanCollide = false
                end
            end

            local function EnablePartControl()
                LocalPlayer.ReplicationFocus = Workspace
                RunService.Heartbeat:Connect(function()
                    sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                    for _, part in pairs(Network.BaseParts) do
                        if part:IsDescendantOf(Workspace) then
                            part.Velocity = Network.Velocity
                        end
                    end
                end)
            end

            EnablePartControl()
        end

        local function ForcePart(v)
            if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
                for _, x in next, v:GetChildren() do
                    if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                        x:Destroy()
                    end
                end
                if v:FindFirstChild("Attachment") then
                    v:FindFirstChild("Attachment"):Destroy()
                end
                if v:FindFirstChild("AlignPosition") then
                    v:FindFirstChild("AlignPosition"):Destroy()
                end
                if v:FindFirstChild("Torque") then
                    v:FindFirstChild("Torque"):Destroy()
                end
                v.CanCollide = false
                
                local Torque = Instance.new("Torque", v)
                Torque.Torque = Vector3.new(1000000, 1000000, 1000000)
                local AlignPosition = Instance.new("AlignPosition", v)
                local Attachment2 = Instance.new("Attachment", v)
                Torque.Attachment0 = Attachment2
                AlignPosition.MaxForce = math.huge
                AlignPosition.MaxVelocity = math.huge
                AlignPosition.Responsiveness = 500
                AlignPosition.Attachment0 = Attachment2
                AlignPosition.Attachment1 = Attachment1
            end
        end

        local function toggleBlackHole()
            blackHoleActive = not blackHoleActive
            if blackHoleActive then
                for _, v in next, Workspace:GetDescendants() do
                    ForcePart(v)
                end

                Workspace.DescendantAdded:Connect(function(v)
                    if blackHoleActive then
                        ForcePart(v)
                    end
                end)

                spawn(function()
                    while blackHoleActive and RunService.RenderStepped:Wait() do
                        angle = angle + math.rad(angleSpeed)

                        local offsetX = math.cos(angle) * radius
                        local offsetZ = math.sin(angle) * radius

                        Attachment1.WorldCFrame = humanoidRootPart.CFrame * CFrame.new(offsetX, 0, offsetZ)
                    end
                end)
                
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Black Hole",
                    Text = "Ativado! Puxando partes para você",
                    Duration = 3
                })
            else
                Attachment1.WorldCFrame = CFrame.new(0, -1000, 0)
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Black Hole",
                    Text = "Desativado",
                    Duration = 3
                })
            end
        end

        LocalPlayer.CharacterAdded:Connect(function()
            humanoidRootPart, Attachment1 = setupPlayer()
            if blackHoleActive then
                toggleBlackHole()
            end
        end)

        -- Slider para o raio do Black Hole
        Tab4:AddSlider({
            Name = "Raio do Black Hole",
            Min = 1,
            Max = 50,
            Default = 10,
            Callback = function(Value)
                radius = Value
            end
        })

        -- Toggle para o Black Hole
        Tab4:AddToggle({
            Name = "Ativar/Desativar Black Hole",
            Default = false,
            Callback = function(Value)
                if Value then
                    toggleBlackHole()
                else
                    blackHoleActive = false
                    Attachment1.WorldCFrame = CFrame.new(0, -1000, 0)
                end
            end
        })

        -- Iniciar o Black Hole
        toggleBlackHole()
    end
})

-- Tab6: RGB
local Tab6 = Window:MakeTab({"RGB", "rainbow"})

-- Velocidade controlada pelo slider (quanto maior, mais rápido)
local rgbSpeed = 1

Tab6:AddSlider({
    Name = "Velocidade RGB",
    Description = "Aumenta a velocidade do efeito RGB",
    Min = 1,
    Max = 5,
    Increase = 1,
    Default = 3,
    Callback = function(Value)
        rgbSpeed = Value
    end
})

-- Função para criar cor RGB suave com HSV
local function getRainbowColor(speedMultiplier)
    local h = (tick() * speedMultiplier % 5) / 5 -- gira o hue suavemente de 0 a 1
    return Color3.fromHSV(h, 1, 1)
end

-- Função para disparar eventos
local function fireServer(eventName, args)
    local event = game:GetService("ReplicatedStorage"):FindFirstChild("RE")
    if event and event:FindFirstChild(eventName) then
        pcall(function()
            event[eventName]:FireServer(unpack(args))
        end)
    end
end

local Section = Tab6:AddSection({"RGB para usar em você"})

-- Nome + Bio RGB  juntos
local nameBioRGBActive = false
Tab6:AddToggle({
    Name = "Nome + Bio RGB ",
    Default = false,
    Callback = function(state)
        nameBioRGBActive = state
        if state then
            task.spawn(function()
                while nameBioRGBActive and LocalPlayer.Character do
                    local color = getRainbowColor(rgbSpeed)
                    fireServer("1RPNam1eColo1r", { "PickingRPNameColor", color })
                    fireServer("1RPNam1eColo1r", { "PickingRPBioColor", color })
                    task.wait(0.03)
                end
            end)
        end
    end
})

-- Nova Aba: House (simplificada)
local Tab7 = Window:MakeTab({"House", "house"})

Tab7:AddButton({
    Name = "Remover Ban",
    Description = "Remove banimento de todas as casas",
    Callback = function()
        local successCount = 0
        local housesChecked = 0
        
        for i = 1, 37 do
            local bannedBlockName = "BannedBlock" .. i
            local bannedBlock = Workspace:FindFirstChild(bannedBlockName, true)
            
            if bannedBlock then
                local success = pcall(function()
                    bannedBlock:Destroy()
                end)
                
                if success then
                    successCount = successCount + 1
                end
                housesChecked = housesChecked + 1
            end
        end
        
        -- Notificação de resultado
        game.StarterGui:SetCore("SendNotification", {
            Title = "Remoção de Ban",
            Text = string.format("Sucesso em %d/%d casas", successCount, housesChecked),
            Duration = 5
        })
    end
})

-- Tab8: Música Visual (CORRIGIDA)
local Tab8 = Window:MakeTab({"Música Visual", "music"})

Tab8:AddSection({"coloque o id"})

local musicInputID = ""
local musicVolume = 0.5
local musicLoop = false
local personalMusicActive = false
local personalCurrentSound = nil

-- Função para tocar som pessoal (apenas para o jogador local)
local function playPersonalSound(soundId)
    if not soundId or soundId == "" or soundId == "0" then
        return false
    end
    
    local numericId = tonumber(soundId)
    if not numericId then
        return false
    end
    
    -- Para o som atual se existir
    if personalCurrentSound then
        personalCurrentSound:Stop()
        personalCurrentSound:Destroy()
        personalCurrentSound = nil
    end
    
    -- Cria o som no PlayerGui do jogador local (só ele ouve)
    local sound = Instance.new("Sound")
    sound.Name = "PersonalMusic"
    sound.SoundId = "rbxassetid://" .. soundId
    sound.Volume = musicVolume
    sound.Looped = musicLoop
    
    -- Coloca no PlayerGui do jogador local
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui")
    sound.Parent = playerGui
    
    -- Tenta tocar o som
    local success, errorMessage = pcall(function()
        sound:Play()
    end)
    
    if success then
        personalCurrentSound = sound
        personalMusicActive = true
        
        -- Remove o som quando terminar (se não for loop)
        if not musicLoop then
            sound.Ended:Connect(function()
                if personalCurrentSound == sound then
                    personalCurrentSound:Stop()
                    personalCurrentSound:Destroy()
                    personalCurrentSound = nil
                    personalMusicActive = false
                end
            end)
        else
            -- Se for loop, destruir após tempo máximo
            delay(600, function() -- 10 minutos
                if personalCurrentSound == sound then
                    personalCurrentSound:Stop()
                    personalCurrentSound:Destroy()
                    personalCurrentSound = nil
                    personalMusicActive = false
                end
            end)
        end
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "Música Visual",
            Text = "Música tocando!",
            Duration = 3
        })
        
        return true
    else
        warn("Erro ao tocar música pessoal: " .. tostring(errorMessage))
        sound:Destroy()
        return false
    end
end

-- Função para parar música pessoal
local function stopPersonalMusic()
    if personalCurrentSound then
        personalCurrentSound:Stop()
        personalCurrentSound:Destroy()
        personalCurrentSound = nil
    end
    personalMusicActive = false
    musicLoop = false
    
    game.StarterGui:SetCore("SendNotification", {
        Title = "Música Pessoal",
        Text = "Música parada!",
        Duration = 3
    })
end

Tab8:AddTextBox({
    Name = "ID da Música",
    Description = "Digite o ID da música (Visual)",
    Default = "",
    PlaceholderText = "Exemplo: 123456789",
    ClearTextOnFocus = true,
    Callback = function(text)
        musicInputID = text
    end
})

Tab8:AddSlider({
    Name = "Volume",
    Description = "Ajuste o volume da música",
    Min = 0,
    Max = 10,
    Default = 0.5,
    Callback = function(value)
        musicVolume = value
        if personalCurrentSound then
            personalCurrentSound.Volume = value
        end
    end
})

Tab8:AddButton({
    Name = "Tocar Música",
    Description = "Tocar música apenas para você",
    Callback = function()
        if musicInputID and musicInputID ~= "" then
            playPersonalSound(musicInputID)
        else
            game.StarterGui:SetCore("SendNotification", {
                Title = "Erro",
                Text = "Digite um ID de música válido",
                Duration = 3
            })
        end
    end
})

Tab8:AddButton({
    Name = "Parar Música",
    Description = "Parar música atual",
    Callback = function()
        stopPersonalMusic()
    end
})

-- Seção com músicas pré-definidas (CORRIGIDA)
Tab8:AddSection({"Músicas Pré-definidas"})

local musicList = {
    {"arrepia xl3", "83331623293224"},
    {"e so mlk bom", "93146696739126"},
    {"Gorillaz - Feel Good Inc", "7140368350"},
    {"The Weeknd - Blinding Lights", "6687605091"},
    {"Daft Punk - Get Lucky", "27697743"},
    {"Minecraft Sweden", "7456309211"},
    {"Rick Astley - Never Gonna Give You Up", "27697259"},
    {"Among Us Drip", "7114743921"},
    {"Tokyo Ghoul Unravel", "2837726272"},
    {"Attack on Titan Theme", "2837721845"}
}

for i, music in ipairs(musicList) do
    Tab8:AddButton({
        Name = music[1],
        Callback = function()
            musicInputID = music[2]
            playPersonalSound(music[2])
        end
    })
end

-- Tab9: Shaders
local Tab9 = Window:MakeTab({"Shaders", "sun"})

Tab9:AddSection({"Sistema de Shaders Shadow"})

-- Configurações globais
local shaderEffects = {}
local currentPreset = ""

-- Função para aplicar efeitos de pós-processamento
local function applyShaderEffect(effectType, properties)
    local lighting = game:GetService("Lighting")
    
    -- Remove efeito anterior do mesmo tipo
    local existingEffect = lighting:FindFirstChild("ShadowShader_" .. effectType)
    if existingEffect then
        existingEffect:Destroy()
    end
    
    -- Cria novo efeito
    local effect = Instance.new(effectType)
    effect.Name = "ShadowShader_" .. effectType
    
    -- Aplica propriedades
    for property, value in pairs(properties) do
        if effect[property] ~= nil then
            effect[property] = value
        end
    end
    
    effect.Enabled = true
    effect.Parent = lighting
    
    shaderEffects[effectType] = effect
    return effect
end

-- Função para remover todos os shaders
local function removeAllShaders()
    local lighting = game:GetService("Lighting")
    
    for effectName, effect in pairs(shaderEffects) do
        if effect and effect.Parent then
            effect:Destroy()
        end
    end
    
    shaderEffects = {}
    
    game.StarterGui:SetCore("SendNotification", {
        Title = "Shaders",
        Text = "Todos os shaders removidos!",
        Duration = 3
    })
end

-- Seção Bloom Effect
Tab9:AddSection({"Bloom Effect"})

Tab9:AddToggle({
    Name = "Ativar Bloom",
    Default = false,
    Callback = function(state)
        if state then
            applyShaderEffect("BloomEffect", {
                Intensity = 1.5,      -- Intensidade do brilho
                Size = 24,            -- Tamanho do efeito
                Threshold = 0.9       -- Limiar de brilho
            })
        else
            local effect = shaderEffects["BloomEffect"]
            if effect then effect:Destroy() end
        end
    end
})

Tab9:AddSlider({
    Name = "Intensidade Bloom",
    Min = 0.1,
    Max = 5,
    Default = 1.5,
    Callback = function(value)
        local effect = shaderEffects["BloomEffect"]
        if effect then
            effect.Intensity = value
        end
    end
})

Tab9:AddSlider({
    Name = "Tamanho Bloom",
    Min = 1,
    Max = 24,
    Default = 24,
    Callback = function(value)
        local effect = shaderEffects["BloomEffect"]
        if effect then
            effect.Size = value
        end
    end
})

-- Seção Color Correction
Tab9:AddSection({"Color Correction"})

Tab9:AddToggle({
    Name = "Ativar Color Correction",
    Default = false,
    Callback = function(state)
        if state then
            applyShaderEffect("ColorCorrectionEffect", {
                Brightness = 0.05,    -- Brilho geral
                Contrast = 1.1,       -- Contraste
                Saturation = 0.8,     -- Saturação das cores
                TintColor = Color3.fromRGB(255, 255, 255) -- Tonalidade
            })
        else
            local effect = shaderEffects["ColorCorrectionEffect"]
            if effect then effect:Destroy() end
        end
    end
})

Tab9:AddSlider({
    Name = "Saturação",
    Min = 0,
    Max = 2,
    Default = 0.8,
    Callback = function(value)
        local effect = shaderEffects["ColorCorrectionEffect"]
        if effect then
            effect.Saturation = value
        end
    end
})

Tab9:AddSlider({
    Name = "Contraste",
    Min = 0.5,
    Max = 2,
    Default = 1.1,
    Callback = function(value)
        local effect = shaderEffects["ColorCorrectionEffect"]
        if effect then
            effect.Contrast = value
        end
    end
})

Tab9:AddSlider({
    Name = "Brilho",
    Min = -0.5,
    Max = 0.5,
    Default = 0.05,
    Callback = function(value)
        local effect = shaderEffects["ColorCorrectionEffect"]
        if effect then
            effect.Brightness = value
        end
    end
})

-- Seção Sun Rays
Tab9:AddSection({"Sun Rays Effect"})

Tab9:AddToggle({
    Name = "Ativar Sun Rays",
    Default = false,
    Callback = function(state)
        if state then
            applyShaderEffect("SunRaysEffect", {
                Intensity = 0.1,      -- Intensidade dos raios
                Spread = 1.0          -- Espalhamento
            })
        else
            local effect = shaderEffects["SunRaysEffect"]
            if effect then effect:Destroy() end
        end
    end
})

Tab9:AddSlider({
    Name = "Intensidade Sun Rays",
    Min = 0.01,
    Max = 0.5,
    Default = 0.1,
    Callback = function(value)
        local effect = shaderEffects["SunRaysEffect"]
        if effect then
            effect.Intensity = value
        end
    end
})

-- Seção Depth of Field (CUIDADO: Pesado para performance)
Tab9:AddSection({"Depth of Field"})

Tab9:AddToggle({
    Name = "Ativar Depth of Field",
    Default = false,
    Callback = function(state)
        if state then
            applyShaderEffect("DepthOfFieldEffect", {
                FocusDistance = 50,   -- Distância do foco
                InFocusRadius = 30,   -- Raio em foco
                NearIntensity = 0.5,  -- Intensidade perto
                FarIntensity = 0.5    -- Intensidade longe
            })
            
            game.StarterGui:SetCore("SendNotification", {
                Title = "Performance",
                Text = "Depth of Field pode afetar FPS!",
                Duration = 5
            })
        else
            local effect = shaderEffects["DepthOfFieldEffect"]
            if effect then effect:Destroy() end
        end
    end
})

-- Seção Blur
Tab9:AddSection({"Blur Effect"})

Tab9:AddToggle({
    Name = "Ativar Blur",
    Default = false,
    Callback = function(state)
        if state then
            applyShaderEffect("BlurEffect", {
                Size = 3  -- Tamanho do desfoque
            })
        else
            local effect = shaderEffects["BlurEffect"]
            if effect then effect:Destroy() end
        end
    end
})

Tab9:AddSlider({
    Name = "Intensidade Blur",
    Min = 1,
    Max = 10,
    Default = 3,
    Callback = function(value)
        local effect = shaderEffects["BlurEffect"]
        if effect then
            effect.Size = value
        end
    end
})

-- Seção de Presets Prontos
Tab9:AddSection({"Presets Prontos"})

-- Presets de shaders
local shaderPresets = {
    ["Vibrante"] = {
        BloomEffect = {Intensity = 2.0, Size = 24, Threshold = 0.8},
        ColorCorrectionEffect = {Brightness = 0.1, Contrast = 1.2, Saturation = 1.0},
        SunRaysEffect = {Intensity = 0.15, Spread = 1.0}
    },
    
    ["Cinematográfico"] = {
        BloomEffect = {Intensity = 1.2, Size = 20, Threshold = 0.9},
        ColorCorrectionEffect = {Brightness = -0.1, Contrast = 1.3, Saturation = 0.6, TintColor = Color3.fromRGB(255, 240, 220)},
        DepthOfFieldEffect = {FocusDistance = 25, InFocusRadius = 15, NearIntensity = 0.7, FarIntensity = 0.7}
    },
    
    ["Realista"] = {
        BloomEffect = {Intensity = 0.8, Size = 16, Threshold = 0.95},
        ColorCorrectionEffect = {Brightness = 0.05, Contrast = 1.1, Saturation = 0.7},
        SunRaysEffect = {Intensity = 0.08, Spread = 0.8}
    },
    
    ["Noturno"] = {
        BloomEffect = {Intensity = 3.0, Size = 24, Threshold = 0.7},
        ColorCorrectionEffect = {Brightness = -0.2, Contrast = 1.4, Saturation = 0.5, TintColor = Color3.fromRGB(180, 200, 255)},
        BlurEffect = {Size = 2}
    },
    
    ["Dream"] = {
        BloomEffect = {Intensity = 2.5, Size = 24, Threshold = 0.6},
        ColorCorrectionEffect = {Brightness = 0.2, Contrast = 1.1, Saturation = 1.2, TintColor = Color3.fromRGB(255, 220, 255)},
        BlurEffect = {Size = 4},
        SunRaysEffect = {Intensity = 0.2, Spread = 1.2}
    }
}

-- Aplicar preset
local function applyShaderPreset(presetName)
    removeAllShaders() -- Remove shaders atuais
    
    local preset = shaderPresets[presetName]
    if preset then
        for effectType, properties in pairs(preset) do
            applyShaderEffect(effectType, properties)
        end
        
        currentPreset = presetName
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "Shaders",
            Text = "Preset " .. presetName .. " aplicado!",
            Duration = 3
        })
    end
end

-- Criar botões para cada preset
for presetName, _ in pairs(shaderPresets) do
    Tab9:AddButton({
        Name = "Preset: " .. presetName,
        Callback = function()
            applyShaderPreset(presetName)
        end
    })
end

-- Seção de Performance
Tab9:AddSection({"Performance"})

Tab9:AddParagraph({"Aviso Performance", "Shaders podem afetar FPS! DepthOfField é o mais pesado."})

Tab9:AddButton({
    Name = "Modo Performance (Low)",
    Callback = function()
        removeAllShaders()
        applyShaderEffect("ColorCorrectionEffect", {
            Brightness = 0.05,
            Contrast = 1.1,
            Saturation = 0.8
        })
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "Performance Mode",
            Text = "Shaders leves ativados para melhor FPS",
            Duration = 3
        })
    end
})

Tab9:AddButton({
    Name = "Remover Todos Shaders",
    Callback = function()
        removeAllShaders()
    end
})

-- Seção Skybox Personalizado
Tab9:AddSection({"Skybox Personalizado"})

Tab9:AddButton({
    Name = "Skybox Noturno Estrelado",
    Callback = function()
        local lighting = game:GetService("Lighting")
        
        -- Remove sky atual
        local currentSky = lighting:FindFirstChildOfClass("Sky")
        if currentSky then
            currentSky:Destroy()
        end
        
        -- Cria novo sky
        local sky = Instance.new("Sky")
        sky.SkyboxBk = "rbxassetid://159454299"
        sky.SkyboxDn = "rbxassetid://159454296"
        sky.SkyboxFt = "rbxassetid://159454293"
        sky.SkyboxLf = "rbxassetid://159454286"
        sky.SkyboxRt = "rbxassetid://159454300"
        sky.SkyboxUp = "rbxassetid://159454288"
        sky.Parent = lighting
        
        -- Ajusta iluminação para noturno
        lighting.ClockTime = 0
        lighting.Brightness = 0.1
        lighting.Ambient = Color3.fromRGB(50, 50, 100)
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "Skybox",
            Text = "Skybox noturno aplicado!",
            Duration = 3
        })
    end
})

Tab9:AddButton({
    Name = "Skybox Realista (Dia)",
    Callback = function()
        local lighting = game:GetService("Lighting")
        
        local currentSky = lighting:FindFirstChildOfClass("Sky")
        if currentSky then
            currentSky:Destroy()
        end
        
        local sky = Instance.new("Sky")
        sky.SkyboxBk = "rbxassetid://6444881967"
        sky.SkyboxDn = "rbxassetid://6444881952"
        sky.SkyboxFt = "rbxassetid://6444881972"
        sky.SkyboxLf = "rbxassetid://6444881985"
        sky.SkyboxRt = "rbxassetid://6444881993"
        sky.SkyboxUp = "rbxassetid://6444882009"
        sky.Parent = lighting
        
        -- Ajusta iluminação para dia
        lighting.ClockTime = 14
        lighting.Brightness = 2
        lighting.Ambient = Color3.fromRGB(100, 100, 100)
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "Skybox",
            Text = "Skybox realista aplicado!",
            Duration = 3
        })
    end
})

Tab9:AddButton({
    Name = "Restaurar Sky Padrão",
    Callback = function()
        local lighting = game:GetService("Lighting")
        
        local currentSky = lighting:FindFirstChildOfClass("Sky")
        if currentSky then
            currentSky:Destroy()
        end
        
        -- Restaura configurações padrão
        lighting.Brightness = 2
        lighting.ClockTime = 14
        lighting.Ambient = Color3.fromRGB(0, 0, 0)
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "Skybox",
            Text = "Skybox padrão restaurado!",
            Duration = 3
        })
    end
})

-- Seção Atmosfera
Tab9:AddSection({"Atmosfera"})

Tab9:AddToggle({
    Name = "Ativar Atmosfera",
    Default = false,
    Callback = function(state)
        local lighting = game:GetService("Lighting")
        
        if state then
            lighting.Atmosphere.Density = 0.3
            lighting.Atmosphere.Offset = 0.5
            lighting.Atmosphere.Color = Color3.fromRGB(200, 200, 255)
            lighting.Atmosphere.Decay = Color3.fromRGB(100, 100, 150)
            lighting.Atmosphere.Glare = 0
            lighting.Atmosphere.Haze = 0
        else
            lighting.Atmosphere.Density = 0
        end
    end
})

-- Informações e Status
Tab9:AddSection({"Status e Informações"})

Tab9:AddParagraph({"Shader Ativo", function() return currentPreset ~= "" and currentPreset or "Nenhum" end})

Tab9:AddButton({
    Name = "Testar Performance",
    Callback = function()
        local startTime = tick()
        local frames = 0
        
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            frames = frames + 1
            if tick() - startTime >= 1 then
                connection:Disconnect()
                
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Performance Test",
                    Text = string.format("FPS: %d", frames),
                    Duration = 5
                })
            end
        end)
    end
})

-- Inicialização segura
game:GetService("RunService").RenderStepped:Connect(function()
    -- Mantém os efeitos ativos se estiverem configurados
    for effectName, effect in pairs(shaderEffects) do
        if effect and effect.Parent then
            effect.Enabled = true
        end
    end
end)

print("Tab Shaders carregada com sucesso!")
